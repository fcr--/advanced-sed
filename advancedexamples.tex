%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced Examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{uniq}

It's not really clear whether this example should be in the Advanced Examples
section, as it does not introduce nor require any non-obvious programming
patterns.

The {\tt uniq} program reads one line at a time from the standard input.
If it is equal to the previous line then it is skipped, otherwise it is printed
to the standard output.  Its pseudocode becomes extremely simple in a higher
level programming language like lua:

%\begin{figure}[h]
%	\label{code:luauniq}
	\begin{Verbatim}
	for line in io.lines() do
	  if line ~= previous_line then
	    print(line)
	    previous_line = line
	  end
	end
	\end{Verbatim}
%	\caption{Pseudocode for {\tt uniq} in lua 5.}
%\end{figure}

While the \sed* version requires us to introduce one of the least common
commands, `{\tt N}':

% sedcode uniq:
\begin{Verbatim}
p; :a; $d; N
  s/^\(.*\)\n\1$/\1/; ta
  s/.*\n//p; ba
\end{Verbatim}

Most of the time our sed programs usually contain a single `{\tt s}' command
and that's it; in those cases sed consumes one line at a time and the pattern
space, the main memory of the program, never contains newline characters:
`\verb|\n|'.  This program however is the exception.

Here our pattern space is used in two ways: It may either contain the text of a
single line, for example when the program begins; or it may as well have ``two
lines'' inside, precisely after the {\tt N} command.
`{\tt N}' reads the next line from the standard input and appends it to the
pattern space with a newline in the middle.

For instance if the input is composed of two lines: `{\tt a}' and `{\tt b}',
processing them with \verb|N;s/\n/-/| will result in `{\tt a-b}'.

Having this behavior is what allows us to write programs in which the lines
cannot be processed independently of one another.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vigen\`ere}

The Vigen\`ere cipher is one of the basic methods shown in most introductory
texts about classic cryptography.  It is based on the Caesar cipher in which the
encryption is done by ``rotating'' or ``shifting'' the characters a given
number of times.

For instance if we rotate the characters by 1 position in a Caesar cipher,
{\tt AMAZING} becomes {\tt BNBAJOH} (each character is substituted by the
next character in the alphabet).  If we use 2 positions, as expected we would
be substituting {\tt A} to {\tt C}, {\tt B} to {\tt D} and so on:
{\tt COCBKPI} for the example above.

Such a simple substitution could be trivially performed in \sed* with the
{\tt y} command.

With Vigen\'ere however, the number of rotations varies for each character and
it is defined by a ``key'' text.  We start the encryption process by repeating
the key until its length is greater or equal to the clear text.  Then each
character of the clear text will have a corresponding character of the key.
If that of the key is an {\tt A} then no rotation is performed,
for {\tt B} we rotate 1 position, for {\tt C} 2 positions in the alphabet,
3 for {\tt D}, and so on.  This means that the {\tt y} command is now out of
the question.

We now present an implementation where the key is sent as the first line,
followed by the text to encrypt:

% sedcode vigenere:
\begin{Verbatim}
	1{ h; d; }
	G; s/\(^\)\|\n/&<ABCDEFGHIJKLMNOPQRSTUVWXYZA>/g
	:a
	  s/\(<[A-Z]*>\)\([^A-Z]\)\(.*\n\)/\2\1\3/
	  s/\(<.*\(.\)\(.\).*>\)\2\(.*<.*\(.\)\(.\).*>\)\6/\1\3\4\5/
	  /\n<.*>A/  s/\(<.*>\)\(.\)\(.*>\)./\2\1\3/
	  />$/{ G; s/>\n/>/; }
	  ta
	s/<.*//
\end{Verbatim}

The state of this program is composed of the hold space which is used for
storing the encryption key, and the pattern space of the form: \emph{encrypted
text} \verb|<ABC...XYZA>| \emph{remaining plain text} \verb|\n|
\verb|<ABC...XYZA>| \emph{remaining key}.

\begin{enumerate}
	\item The key is stored into the hold space, and we proceed to the next
		line without any output: {\tt d}.
	\item We begin by appending to the clear text (in the pattern space) a
		newline and the key that we have stored in the hold space.  Before each
		of the lines of our pattern space we append the {\tt <ABC...XYZA>} text,
		which we will later use for the rotations.

		Note that on some implementations the precedence order of the carret
		and the ``or'' operator (\verb:\|:) may be different.  That why we
		enclosed the caret into a group.
	\addtocounter{enumi}{1}
	\item Here we add a rule for those characters that are not in the A-Z
		class, like punctuation marks.  ``Accepting'' a character is done
		by moving it from the beginning of the \emph{remaining plain text} to
		the end of the \emph{encrypted text}.
    \item This is the rule for the rotation, the core of this implementation.
\end{enumerate}

\subsection{Height of a Tree}

In this simple example we receive an n-ary tree and return its height in
unary.  An example input could be \verb|[1,[[5],8],10,[3,2],5]| with the
corresponding output \verb|xxx|, as it shows 3 nesting levels.

% sedcode treeheight:
\begin{Verbatim}
	s/[^],[]//g; s/,,*/,/g; s/^,*//; s/,*$//; s/\[,*/[/g; s/,*\]/]/g
	:a
	  s/\[\(x*\)\]/\1x/g
	  s/\(xx*\)\(x*\),\1\(x*\)/\1\2\3/g
	  ta
\end{Verbatim}

The first line just deletes everything but the brackets and commas, and
it also deletes any redundant comma, de-duplicating and leaving only
those that separate children, ie: {\tt [],[]}.

Then in the line 3 we handle any node with 0 or 1 child, by converting
them to their height: one more than that of their child.  Final nodes will
have height 1.

Finally on the line 4 we calculate the maximum of two consecutive heights
by substituting them to their maximum.  That way on each substitution we
will be removing one comma, eventually reaching the case when the line 3
is applicable on that node.

Since the tree representation is a finite string, it means that there can
only be a finite number of children.  Note that since we remove any nodes
but ``arrays'', all the final nodes will always be empty arrays, and so
it could be defined inductively as follows:
either a node is an empty array $\texttt{[]}\in N$, or if it is
composed of children $c_1, \ldots, c_k\in N$ that are also nodes, then
$\texttt{[}c_1\texttt{,}\ldots\texttt{,}c_k\texttt{]} \in N$.  This is why
it eventually ends.

\subsection{Dijkstra}
% Dijkstra:
We have the following format for the nodes depending on their state:
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		$\texttt{<}node\texttt{,x}^*\texttt{>}$ & Nodes to iterate.\\
		\hline
		$\texttt{<}node\texttt{;x}^*\texttt{>}$
			& New nodes created at the current iteration.\\
		\hline
		$\texttt{<}node\texttt{!x}^*\texttt{>}$ & Node being iterated.\\
		\hline
		$\texttt{<}node\texttt{.x}^*\texttt{>}$ & Iterated nodes.\\
		\hline
	\end{tabular}
\end{center}

While for the edges:
\begin{center}
	\begin{tabular}{|l|l|}
		\hline
		$\texttt{<}sourceNode\texttt{,}targetNode\texttt{,x}^*\texttt{>}$
			& Edges ready to visit.\\
		\hline
		$\texttt{<}sourceNode\texttt{,}targetNode\texttt{:x}^*\texttt{>}$
			& Visited edges.\\
		\hline
	\end{tabular}
\end{center}

% sedcode dijkstra:
\begin{Verbatim}
	:i; /<[^>,]*,x*>/!{
	  :m
	  s/\(<[^;>]*\;x*>\)\(<[^.>]*\.x*>\)/\2\1/
	  s/<\([^.;>]*\)[.;]\(x*\)xx*>\(.*<\1;\2>\)/\3/
	  s/\(<\([^,;>]*\)[;.]\(x*\)>.*\)<\2;\3x*>/\1/; tm
	  /;/!q; y/;/,/
	bi;}
	s/,/!/
	:a
	  s/\(<\([^>]*\)!\(x*\)>.*<\2,\([^,]*\)\),\(x*>\)/<\4;\3\5\1:\5/
	  ta
	y/:!/,./; bi
\end{Verbatim}

\todo{explain Dijkstra's algorithm implementation.}

\todo{add more examples}

% another advanced example could be a program to select child elements from
% json strings, the first line could be the selector like "foo".0."id", and the
% remaining lines could be json objects (which could span several lines
% themselves).
