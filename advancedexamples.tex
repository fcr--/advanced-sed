%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced Examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{uniq}

It's not really clear whether this example should be in the Advanced Examples
section, as it does not introduce nor require any non-obvious programming
patterns.

The {\tt uniq} program reads one line at a time from the standard input.
If it is equal to the previous line then it is skipped, otherwise it is printed
to the standard output.  Its pseudocode becomes extremely simple in a higher
level programming language like lua:

%\begin{figure}[h]
%	\label{code:luauniq}
	\begin{Verbatim}
	for line in io.lines() do
	  if line ~= previous_line then
	    print(line)
	    previous_line = line
	  end
	end
	\end{Verbatim}
%	\caption{Pseudocode for {\tt uniq} in lua 5.}
%\end{figure}

While the \sed version requires us to introduce one of the least common
commands, `{\tt N}':

% sedcode uniq:
\begin{Verbatim}
p; :a; $d; N
  s/\(.*\)\n\1$/\1/; ta
  s/.*\n//p; ba
\end{Verbatim}

Most of the time our sed programs usually contain a single `{\tt s}' command
and that's it; in those cases sed consumes one line at a time and the pattern
space, the main memory of the program, never contains newline characters:
`\verb|\n|'.  This program however is the exception.

Here our pattern space is used in two ways: It may either contain the text of a
single line, for example when the program begins; or it may as well have ``two
lines'' inside, precisely after the {\tt N} command.
`{\tt N}' reads the next line from the standard input and appends it to the
pattern space with a newline in the middle.

For instance if the input is composed of two lines: `{\tt a}' and `{\tt b}',
processing them with \verb|N;s/\n/-/| will result in `{\tt a-b}'.

Having this behavior is what allows us to write programs in which the lines
cannot be processed independently of one another.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vigen\`ere}

The Vigen\`ere cipher is one of the basic methods shown in most introductory
texts about classic criptography.  It is based on the Caesar cipher in which the
encryption is done by ``rotating'' or ``shifting'' the characters a given
number of times.

For instance if we rotate the caracters by 1 position in a Caesar cipher,
{\tt AMAZING} becomes {\tt BNBAJOH} (each character is substituted by the
next character in the alphabet).  If we use 2 positions, as expected we would
be substituting {\tt A} to {\tt C}, {\tt B} to {\tt D} and so on:
{\tt COCBKPI} for the example above.

Such a simple substitution could be trivially performed in \sed with the
{\tt y} command.

With Vigen\'ere however, the number of rotations varies for each character and
it is defined by a ``key'' text.  We start the encryption process by repeating
the key until its length is greater or equal to the clear text.  Then each
character of the clear text will have a corresponding character of the key.
If that of the key is an {\tt A} then no rotation is performed,
for {\tt B} we rotate 1 position, for {\tt C} 2 positions in the alphabet,
3 for {\tt D}, and so on.  This means that the {\tt y} command is now out of
the question.

We now present an implementation where the key is sent as the first line,
followed by the text to encrypt:

% sedcode vigenere:
\begin{Verbatim}
	1{ h; d }
	G; s/\(^\)\|\n/&<ABCDEFGHIJKLMNOPQRSTUVWXYZA>/g
	:a
	  s/\(<[A-Z]*>\)\([^A-Z]\)\(.*\n\)/\2\1\3/
	  s/\(<.*\(.\)\(.\).*>\)\2\(.*<.*\(.\)\(.\).*>\)\6/\1\3\4\5/
	  /\n<.*>A/  s/\(<.*>\)\(.\)\(.*>\)./\2\1\3/
	  />$/{ G; s/>\n/>/ }
	  ta
	s/<.*//
\end{Verbatim}

\begin{enumerate}
	\item The key is stored into the hold space, and we proceed to the next
		line without any output: {\tt d}.
	\item We begin by appending to the clear text (in the pattern space) a
		newline and the key that we have stored in the hold space.  Before each
		of the lines of our pattern space we append the {\tt <ABC...XYZA>} text,
		which we will later use for the rotations.

		Note that on some implementations the precedence order of the carret
		and the ``or'' operator (\verb:\|:) may be different.  That why we
		enclosed the caret into a group.
	\item \todo{complete}
\end{enumerate}


\todo{add more examples}

% another advanced example could be a program to select child elements from
% json strings, the first line could be the selector like "foo".0."id", and the
% remaining lines could be json objects (which could span several lines
% themselves).
